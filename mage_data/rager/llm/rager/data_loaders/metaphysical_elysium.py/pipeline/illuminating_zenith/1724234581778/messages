{"result_id": "abe58a4de67b48dba1ee66ec9e21eda6", "data_type": "text/plain", "error": null, "metadata": null, "output": "IndexNotFoundError: {'error': {'root_cause': [{'type': 'index_not_found_exception', 'reason': 'no such index [documents]', 'resource.type': 'index_or_alias', 'resource.id': 'documents', 'index_uuid': '_na_', 'index': 'documents'}], 'type': 'index_not_found_exception', 'reason': 'no such index [documents]', 'resource.type': 'index_or_alias', 'resource.id': 'documents', 'index_uuid': '_na_', 'index': 'documents'}, 'status': 404}\n", "process": {"data": [], "exitcode": null, "is_alive": false, "internal_state": "INIT", "kernel_uuid": "metaphysical_elysium", "message": "from typing import Dict, List, Union\nfrom elasticsearch import Elasticsearch, exceptions\n\nDEFAULT_QUERY = \"When is the next cohort?\"\n\n@data_loader\ndef search(*args, **kwargs) -> List[Dict]:\n    \"\"\"\n    Retrieve documents from Elasticsearch based on a query.\n\n    Args:\n        query (str): The search query.\n        connection_string (str): Elasticsearch connection string.\n        index_name (str): The Elasticsearch index name or pattern.\n        top_k (int): Number of top results to retrieve.\n        chunk_column (str): The field to retrieve from the documents.\n\n    Returns:\n        List[Dict]: A list of documents matching the query.\n    \"\"\"\n    \n    query = kwargs.get('query', DEFAULT_QUERY)\n    connection_string = kwargs.get('connection_string', 'http://localhost:9200')\n    index_name = kwargs.get('index_name', 'documents*')  # Use a wildcard to match all indices\n    top_k = kwargs.get('top_k', 5)\n    chunk_column = kwargs.get('chunk_column', 'text')\n\n    # Initialize Elasticsearch client\n    es_client = Elasticsearch(connection_string)\n\n    # Construct the search query\n    search_query = {\n        \"size\": top_k,\n        \"query\": {\n            \"match\": {\n                \"text\": query\n            }\n        }\n    }\n\n    # Perform the search query\n    try:\n        response = es_client.search(\n            index=index_name,\n            body=search_query\n        )\n\n        # Extract the relevant fields from the response\n        results = [hit['_source'].get(chunk_column, '') for hit in response['hits']['hits']]\n        return results\n\n    except exceptions.NotFoundError as e:\n        print(f\"IndexNotFoundError: {e.info}\")\n        return []\n    except exceptions.RequestError as e:\n        print(f\"RequestError: {e.info}\")\n        return []\n    except exceptions.TransportError as e:\n        print(f\"TransportError: {e.info}\")\n        return []\n    except Exception as e:\n        print(f\"Unexpected error: {e}\")\n        return []\n", "message_request_uuid": "1724234581778", "message_uuid": "edeb33e50a59485e88ed2de1f47d8d35", "output_manager": {"namespace": "pipeline/illuminating_zenith", "path": "llm/rager/data_loaders/metaphysical_elysium.py", "uuid": "1724234581778"}, "pid": "edeb33e50a59485e88ed2de1f47d8d35", "pid_spawn": null, "source": "metaphysical_elysium", "stream": "code_executions", "timestamp": null, "timestamp_end": null, "uuid": "metaphysical_elysium"}, "status": "running", "type": "stdout", "uuid": "metaphysical_elysium", "timestamp": 1724234581866, "output_text": "IndexNotFoundError: {'error': {'root_cause': [{'type': 'index_not_found_exception', 'reason': 'no such index [documents]', 'resource.type': 'index_or_alias', 'resource.id': 'documents', 'index_uuid': '_na_', 'index': 'documents'}], 'type': 'index_not_found_exception', 'reason': 'no such index [documents]', 'resource.type': 'index_or_alias', 'resource.id': 'documents', 'index_uuid': '_na_', 'index': 'documents'}, 'status': 404}\n"}
{"result_id": "31ddbb3262ea493bbdd385953b5636ed", "data_type": null, "error": null, "metadata": {"namespace": "pipeline/illuminating_zenith", "path": "llm/rager/data_loaders/metaphysical_elysium.py", "uuid": "1724234581778", "block_type": "data_loader", "block_uuid": "metaphysical_elysium", "execution_partition": null, "pipeline_uuid": "illuminating_zenith"}, "output": "", "process": {"data": [], "exitcode": null, "is_alive": false, "internal_state": "INIT", "kernel_uuid": "metaphysical_elysium", "message": "from typing import Dict, List, Union\nfrom elasticsearch import Elasticsearch, exceptions\n\nDEFAULT_QUERY = \"When is the next cohort?\"\n\n@data_loader\ndef search(*args, **kwargs) -> List[Dict]:\n    \"\"\"\n    Retrieve documents from Elasticsearch based on a query.\n\n    Args:\n        query (str): The search query.\n        connection_string (str): Elasticsearch connection string.\n        index_name (str): The Elasticsearch index name or pattern.\n        top_k (int): Number of top results to retrieve.\n        chunk_column (str): The field to retrieve from the documents.\n\n    Returns:\n        List[Dict]: A list of documents matching the query.\n    \"\"\"\n    \n    query = kwargs.get('query', DEFAULT_QUERY)\n    connection_string = kwargs.get('connection_string', 'http://localhost:9200')\n    index_name = kwargs.get('index_name', 'documents*')  # Use a wildcard to match all indices\n    top_k = kwargs.get('top_k', 5)\n    chunk_column = kwargs.get('chunk_column', 'text')\n\n    # Initialize Elasticsearch client\n    es_client = Elasticsearch(connection_string)\n\n    # Construct the search query\n    search_query = {\n        \"size\": top_k,\n        \"query\": {\n            \"match\": {\n                \"text\": query\n            }\n        }\n    }\n\n    # Perform the search query\n    try:\n        response = es_client.search(\n            index=index_name,\n            body=search_query\n        )\n\n        # Extract the relevant fields from the response\n        results = [hit['_source'].get(chunk_column, '') for hit in response['hits']['hits']]\n        return results\n\n    except exceptions.NotFoundError as e:\n        print(f\"IndexNotFoundError: {e.info}\")\n        return []\n    except exceptions.RequestError as e:\n        print(f\"RequestError: {e.info}\")\n        return []\n    except exceptions.TransportError as e:\n        print(f\"TransportError: {e.info}\")\n        return []\n    except Exception as e:\n        print(f\"Unexpected error: {e}\")\n        return []\n", "message_request_uuid": "1724234581778", "message_uuid": "edeb33e50a59485e88ed2de1f47d8d35", "output_manager": {"namespace": "pipeline/illuminating_zenith", "path": "llm/rager/data_loaders/metaphysical_elysium.py", "uuid": "1724234581778"}, "pid": "edeb33e50a59485e88ed2de1f47d8d35", "pid_spawn": null, "source": "metaphysical_elysium", "stream": "code_executions", "timestamp": null, "timestamp_end": null, "uuid": "metaphysical_elysium"}, "status": "success", "type": "output", "uuid": "metaphysical_elysium", "timestamp": 1724234581874, "output_text": ""}
